# 30-Day-LeetCoding-Challenge-May
### data structure: stack, queue, deque, tuple, dict, hash, set
### graph
1. Counter, dict, hash
2. Bit-wise, binary representation; operations (XOR, OR, AND), shifts, etc.
3. Binary Tree Search
    * a dummy root, return root.left
    * curr_node = root = TreeNode(ini_val), return root, curr_node as a pointer to traverse BST
    * traverse: connect + append temp [] + move pointer
    * left tree: append; 
    * right tree: finish/close traverse, while temp.pop() to implement left --> right
    * is_full(), is_leaf(), get_hight()
4. Recursion (helper function exit cases return + recursion; initiate inputs + temp{} or existing arrays)
5. Count for votes +=, -=
6. "".join(strings).lstrip('0') or '0'
7. Dynamic append, pop.() and cum-counter++
8. all(v >= 0 for v in a.itervalues())
9. Trie (prefix tree)
10. Kadane's algorithm, curr_max, curr_min, tot_max, tot_min, accu_sum rolling
11. Linked list
12. 26-character dict + rolling counter (hash)
13. append( (key, val) )
14. BST + InOrderTraversal = sorted array
15. 2D-DP dynamic counters
16. sorted(temp.items(), reverse = True, key = lambda x: x[1])
17. string += sub_string * freq
18. {u:i for i, u in enumerate(vocab)}, vocab.items()
19. dict.get()+1 for not-existing pairs
20. Two pointers (l, r) + while loop(s)
    * sum+= sum-=
    * accu_sum is non-decreasing
    * check diff = target - accu_sum is in temp [] or {}, back track index i
    * **a contiguous subarray**
    * a dummy start, hash {-1:0} or {-1:[0]}
    * curr_max/curr_min = max/min(curr_max/curr_min, a iterable item)
21. idx2char, char2idx, ord()
22. LCS, BST + a dummy start, 2D-DP
23. BFS/DFS: bfs queue dfs stack

